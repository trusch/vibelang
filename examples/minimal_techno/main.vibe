// Minimal Techno - Hypnotic and driving
// Classic Berlin-style minimal with subtle variations
// Full 3-minute arrangement (~96 bars at 130 BPM)

set_tempo(130);

// Core sounds
import "stdlib/drums/kicks/kick_909.vibe";
import "stdlib/drums/hihats/hihat_808_closed.vibe";
import "stdlib/drums/hihats/hihat_808_open.vibe";
import "stdlib/drums/claps/clap_808.vibe";
import "stdlib/drums/percussion/rim.vibe";
import "stdlib/bass/pluck/pluck_bright.vibe";

import "stdlib/effects/reverb.vibe";
import "stdlib/effects/phaser.vibe";
import "stdlib/effects/moog_filter.vibe";

// =============================================================================
// ARRANGEMENT STRUCTURE (96 bars total = ~3 minutes at 130 BPM)
// =============================================================================
// Bars 0-8:    INTRO - Hats only, atmospheric
// Bars 8-16:   BUILD - Add kick, rimshot
// Bars 16-24:  DROP 1 - Full drums, bass enters
// Bars 24-32:  GROOVE - Add synth stab
// Bars 32-40:  BREAKDOWN - Strip back, reverb swell
// Bars 40-48:  DROP 2 - Full power, all elements
// Bars 48-56:  VARIATION - Pattern changes
// Bars 56-64:  DROP 3 - Peak energy
// Bars 64-72:  GROOVE 2 - Sustained energy with variations
// Bars 72-80:  BREAKDOWN 2 - Strip back, big reverb build
// Bars 80-88:  FINAL DROP - Maximum energy
// Bars 88-96:  OUTRO - Gradual fade out
// =============================================================================

// === CUSTOM SYNTH DEFINITIONS ===

define_synthdef("stab")
    .param("freq", 220.0)
    .param("amp", 0.3)
    .param("cutoff", 1200.0)
    .param("gate", 1.0)
    .body(|freq, amp, cutoff, gate| {
    let env = envelope()
        .adsr(0.01, 0.3, 0.2, 0.1)
        .gate(gate)
        .cleanup_on_finish()
        .build();

    let osc1 = saw_ar(freq);
    let osc2 = saw_ar(freq * 1.5);
    let osc3 = saw_ar(freq * 2.0);
    let mix = (osc1 + osc2 * 0.5 + osc3 * 0.3) * 0.3;

    let filt = rlpf_ar(mix, cutoff, 0.3);
    filt * env * amp
});

define_synthdef("pad")
    .param("freq", 220.0)
    .param("amp", 0.15)
    .param("cutoff", 800.0)
    .param("gate", 1.0)
    .body(|freq, amp, cutoff, gate| {

    let env = envelope()
        .adsr(0.5, 0.3, 0.7, 2.0)
        .gate(gate)
        .cleanup_on_finish()
        .build();

    let osc1 = saw_ar(freq);
    let osc2 = saw_ar(freq * 1.002);
    let osc3 = saw_ar(freq * 0.998);
    let mix = (osc1 + osc2 + osc3) * 0.2;

    let filt = rlpf_ar(mix, cutoff, 0.5);
    filt * env * amp
});

define_synthdef("riser")
    .param("amp", 0.3)
    .param("cutoff", 200.0)
    .param("res", 0.5)
    .param("gate", 1.0)
    .body(|amp, cutoff, res, gate| {
    let env = envelope()
        .adsr(0.01, 0.1, 1.0, 0.3)
        .gate(gate)
        .cleanup_on_finish()
        .build();
    let noise = white_noise_ar();
    let filt = rhpf_ar(noise, cutoff, res);
    filt * env * amp
});

// === DRUMS ===
let drums = define_group("Drums", || {
    let kick = voice("kick").synth("kick_909").gain(db(-17.90));
    let hat_c = voice("hat_c").synth("hihat_808_closed").gain(db(-18));
    let hat_o = voice("hat_o").synth("hihat_808_open").gain(db(-20));
    let clap = voice("clap").synth("clap_808").gain(db(-14));
    let rim = voice("rim").synth("rim").gain(db(-16));

    // Patterns
    let kick_main = pattern("kick_main").on(kick).step("x... x... x... x...");
    let kick_var = pattern("kick_var").on(kick).step("x... x... x... x.x.");
    let kick_half = pattern("kick_half").on(kick).step("x... .... x... ....");
    let kick_build = pattern("kick_build")
        .on(kick)
        .step("x... x... x.x. x.x.");

    let hat_off = pattern("hat_off").on(hat_c).step(".x.x .x.x");
    let hat_var = pattern("hat_var").on(hat_c).step(".x.x .xxx");
    let hat_busy = pattern("hat_busy").on(hat_c).step("x.xx x.xx");
    let hat_16th = pattern("hat_16th").on(hat_c).step("xxxx xxxx");
    let hat_open = pattern("hat_open").on(hat_o).step(".... .... x... ....");
    let hat_open_var = pattern("hat_open_var")
        .on(hat_o)
        .step(".... x... .... x...");

    let clap_back = pattern("clap_back").on(clap).step(".... x... .... x...");
    let clap_var = pattern("clap_var").on(clap).step(".... x... .... x..x");
    let clap_build = pattern("clap_build")
        .on(clap)
        .step(".... x... x... x.x.");

    let rim_pattern = pattern("rim").on(rim).step("..x. ..x. ..x. ....");
    let rim_var = pattern("rim_var").on(rim).step("..x. .... x.x. ....");
    let rim_sparse = pattern("rim_sparse").on(rim).step("..x. .... .... ....");

    // Fades
    let fade_intro = fade("drums_intro")
        .on_group("Drums")
        .param("amp")
        .from(db(-20.0))
        .to(db(0.0))
        .over_bars(8);
    let fade_outro = fade("drums_outro")
        .on_group("Drums")
        .param("amp")
        .from(db(0.0))
        .to(db(-40.0))
        .over_bars(8);

    // Section sequences (8 bars each) - must .apply() to register for nesting
    let intro = sequence("drums_intro_seq").loop_bars(8)
        .clip(0..bars(8), hat_off)
        .clip(0..bars(8), fade_intro)
        .apply();

    let build = sequence("drums_build_seq").loop_bars(8)
        .clip(0..bars(8), hat_off)
        .clip(0..bars(8), kick_half)
        .clip(bars(4)..bars(8), rim_sparse)
        .apply();

    let drop1 = sequence("drums_drop1_seq").loop_bars(8)
        .clip(0..bars(8), kick_main)
        .clip(0..bars(8), hat_off)
        .clip(0..bars(8), clap_back)
        .clip(bars(2)..bars(8), rim_pattern)
        .clip(bars(4)..bars(8), hat_open)
        .apply();

    let groove = sequence("drums_groove_seq").loop_bars(8)
        .clip(0..bars(8), kick_main)
        .clip(0..bars(4), hat_off)
        .clip(bars(4)..bars(8), hat_var)
        .clip(0..bars(8), clap_back)
        .clip(0..bars(8), hat_open)
        .clip(bars(2)..bars(6), rim_pattern)
        .apply();

    let breakdown = sequence("drums_breakdown_seq").loop_bars(8)
        .clip(0..bars(4), kick_half)
        .clip(0..bars(8), hat_off)
        .clip(bars(4)..bars(6), rim_sparse)
        .clip(bars(6)..bars(8), kick_build)
        .clip(bars(6)..bars(8), hat_16th)
        .clip(bars(6)..bars(8), clap_build)
        .apply();

    let drop2 = sequence("drums_drop2_seq").loop_bars(8)
        .clip(0..bars(8), kick_main)
        .clip(0..bars(4), hat_var)
        .clip(bars(4)..bars(8), hat_busy)
        .clip(0..bars(8), clap_back)
        .clip(0..bars(8), hat_open)
        .clip(bars(2)..bars(8), rim_pattern)
        .apply();

    let variation = sequence("drums_variation_seq").loop_bars(8)
        .clip(0..bars(8), kick_var)
        .clip(0..bars(4), hat_busy)
        .clip(bars(4)..bars(8), hat_var)
        .clip(0..bars(8), clap_var)
        .clip(0..bars(8), hat_open_var)
        .clip(bars(2)..bars(6), rim_var)
        .apply();

    let drop3 = sequence("drums_drop3_seq").loop_bars(8)
        .clip(0..bars(8), kick_main)
        .clip(0..bars(4), hat_busy)
        .clip(bars(4)..bars(8), hat_var)
        .clip(0..bars(8), clap_back)
        .clip(0..bars(8), hat_open)
        .clip(bars(2)..bars(6), rim_pattern)
        .apply();

    let groove2 = sequence("drums_groove2_seq").loop_bars(8)
        .clip(0..bars(8), kick_main)
        .clip(0..bars(4), hat_off)
        .clip(bars(4)..bars(8), hat_var)
        .clip(0..bars(8), clap_back)
        .clip(bars(2)..bars(6), hat_open)
        .clip(bars(2)..bars(8), rim_pattern)
        .apply();

    let final_drop = sequence("drums_final_seq").loop_bars(8)
        .clip(0..bars(8), kick_main)
        .clip(0..bars(4), hat_busy)
        .clip(bars(4)..bars(8), hat_var)
        .clip(0..bars(8), clap_back)
        .clip(0..bars(8), hat_open)
        .clip(bars(2)..bars(6), rim_pattern)
        .apply();

    let outro = sequence("drums_outro_seq").loop_bars(8)
        .clip(0..bars(8), fade_outro)
        .clip(0..bars(4), kick_main)
        .clip(0..bars(8), hat_off)
        .clip(0..bars(4), clap_back)
        .clip(bars(4)..bars(8), kick_half)
        .apply();

    // Main arrangement using nested sequences
    sequence("drums_main")
        .loop_bars(96)
        .clip(bars(0)..bars(8), intro)
        .clip(bars(8)..bars(16), build)
        .clip(bars(16)..bars(24), drop1)
        .clip(bars(24)..bars(32), groove)
        .clip(bars(32)..bars(40), breakdown)
        .clip(bars(40)..bars(48), drop2)
        .clip(bars(48)..bars(56), variation)
        .clip(bars(56)..bars(64), drop3)
        .clip(bars(64)..bars(72), groove2)
        .clip(bars(72)..bars(80), breakdown)
        .clip(bars(80)..bars(88), final_drop)
        .clip(bars(88)..bars(96), outro)
        .start();

    fx("clap_verb")
        .synth("reverb")
        .param("room", 0.4)
        .param("mix", 0.2)
        .apply();
});

// === BASS ===
let bass = define_group("Bass", || {
    let sub = voice("sub")
        .synth("pluck_bright")
        .set_param("amp", db(-23.60))
        .poly(1);

    let bass_pulse = melody("bass_pulse")
        .on(sub)
        .notes("E1 - - - | G1 - - - | E1 - - - | E1 - E1 -");
    let bass_var = melody("bass_var")
        .on(sub)
        .notes("E1 - - - | E1 - G1 - | E1 - - - | D1 - E1 -");
    let bass_drive = melody("bass_drive")
        .on(sub)
        .notes("E1 - E1 - | G1 - E1 - | E1 - E1 - | D1 - E1 -");
    let bass_minimal = melody("bass_minimal")
        .on(sub)
        .notes("E1 - - - | - - - - | E1 - - - | - - - -");
    let bass_build = melody("bass_build")
        .on(sub)
        .notes("E1 - - - | E1 - - - | E1 - E1 - | E1 E1 E1 E1");

    let fade_outro = fade("bass_outro")
        .on_group("Bass")
        .param("amp")
        .from(db(0.0))
        .to(db(-40.0))
        .over_bars(8);

    // Section sequences - must .apply() to register for nesting
    let drop1 = sequence("bass_drop1")
        .loop_bars(8)
        .clip(0..bars(8), bass_pulse)
        .apply();
    let groove = sequence("bass_groove")
        .loop_bars(8)
        .clip(0..bars(8), bass_pulse)
        .apply();
    let breakdown = sequence("bass_breakdown").loop_bars(8)
        .clip(0..bars(4), bass_minimal)
        .clip(bars(6)..bars(8), bass_build)
        .apply();
    let drop2 = sequence("bass_drop2")
        .loop_bars(8)
        .clip(0..bars(8), bass_drive)
        .apply();
    let variation = sequence("bass_variation").loop_bars(8)
        .clip(0..bars(4), bass_var)
        .clip(bars(4)..bars(8), bass_drive)
        .apply();
    let drop3 = sequence("bass_drop3")
        .loop_bars(8)
        .clip(0..bars(8), bass_drive)
        .apply();
    let groove2 = sequence("bass_groove2").loop_bars(8)
        .clip(0..bars(4), bass_pulse)
        .clip(bars(4)..bars(8), bass_var)
        .apply();
    let final_drop = sequence("bass_final")
        .loop_bars(8)
        .clip(0..bars(8), bass_drive)
        .apply();
    let outro = sequence("bass_outro_seq").loop_bars(8)
        .clip(0..bars(8), fade_outro)
        .clip(0..bars(4), bass_pulse)
        .clip(bars(4)..bars(6), bass_minimal)
        .apply();

    sequence("bass_main")
        .loop_bars(96)
        .clip(bars(16)..bars(24), drop1)
        .clip(bars(24)..bars(32), groove)
        .clip(bars(32)..bars(40), breakdown)
        .clip(bars(40)..bars(48), drop2)
        .clip(bars(48)..bars(56), variation)
        .clip(bars(56)..bars(64), drop3)
        .clip(bars(64)..bars(72), groove2)
        .clip(bars(72)..bars(80), breakdown)
        .clip(bars(80)..bars(88), final_drop)
        .clip(bars(88)..bars(96), outro)
        .start();
});

// === SYNTH STAB ===
let synth = define_group("Synth", || {
    let stab = voice("stab").synth("stab").gain(db(-6)).poly(4);

    // Chicago-inspired signature melody and variations
    let chicago = melody("chicago").on(stab)
        .notes("E3 . . E3 . . E3 . G3 . . G3 . . E3 . | E3 . . E3 . . G3 . E3 . . . . . . .");
    let chicago_high = melody("chicago_high").on(stab)
        .notes("E3 . . E3 . . E3 . G3 . . B3 . . E3 . | E3 . . G3 . . B3 . E3 . . . . . . .");
    let chicago_minimal = melody("chicago_minimal").on(stab)
        .notes("E3 . . E3 . . E3 . . . . . . . E3 . | E3 . . E3 . . . . E3 . . . . . . .");
    let chicago_busy = melody("chicago_busy").on(stab)
        .notes("E3 . E3 E3 . . E3 . G3 . G3 G3 . . E3 . | E3 . E3 E3 . . G3 . E3 . E3 . . . . .");
    let chicago_offbeat = melody("chicago_offbeat").on(stab)
        .notes(". E3 . . E3 . . E3 . G3 . . G3 . . E3 | . E3 . . E3 . . G3 . E3 . . . . . .");
    let chicago_octave = melody("chicago_octave").on(stab)
        .notes("E4 . . E4 . . E4 . G4 . . G4 . . E4 . | E4 . . E4 . . G4 . E4 . . . . . . .");
    let chicago_held = melody("chicago_held").on(stab)
        .notes("E3 - - - - - E3 - G3 - - - - - E3 - | E3 - - - - - G3 - E3 - - - - - - -");
    let chicago_build = melody("chicago_build").on(stab)
        .notes("E3 . . . . . E3 . . . . . E3 . . . | E3 . . E3 . . E3 . E3 . E3 E3 E3 E3 E3");
    let chicago_sparse = melody("chicago_sparse").on(stab)
        .notes("E3 - - - - - - - - - - - - - - - | . . . . . . . . G3 - - - - - - -");

    let fade_outro = fade("synth_outro")
        .on_group("Synth")
        .param("amp")
        .from(db(0.0))
        .to(db(-40.0))
        .over_bars(8);

    // Effect fades
    let phaser_sweep = fade("phaser_sweep")
        .on_effect("stab_phaser")
        .param("rate")
        .from(0.2)
        .to(2.5)
        .over_bars(4);
    let phaser_return = fade("phaser_return")
        .on_effect("stab_phaser")
        .param("rate")
        .from(2.5)
        .to(0.2)
        .over_bars(2);
    let filter_open = fade("filter_open")
        .on_effect("stab_moog")
        .param("cutoff")
        .from(800.0)
        .to(6000.0)
        .over_bars(4);
    let filter_close = fade("filter_close")
        .on_effect("stab_moog")
        .param("cutoff")
        .from(6000.0)
        .to(800.0)
        .over_bars(2);
    let filter_big_open = fade("filter_big_open")
        .on_effect("stab_moog")
        .param("cutoff")
        .from(600.0)
        .to(8000.0)
        .over_bars(8);
    let filter_big_close = fade("filter_big_close")
        .on_effect("stab_moog")
        .param("cutoff")
        .from(8000.0)
        .to(600.0)
        .over_bars(2);
    let verb_swell = fade("verb_swell")
        .on_effect("stab_verb")
        .param("mix")
        .from(0.2)
        .to(0.7)
        .over_bars(4);
    let verb_return = fade("verb_return")
        .on_effect("stab_verb")
        .param("mix")
        .from(0.7)
        .to(0.2)
        .over_bars(2);

    // Section sequences - must .apply() to register for nesting
    let groove = sequence("synth_groove")
        .loop_bars(8)
        .clip(0..bars(8), chicago)
        .apply();

    let breakdown = sequence("synth_breakdown").loop_bars(8)
        .clip(0..bars(6), chicago_sparse)
        .clip(0..bars(4), verb_swell)
        .clip(bars(6)..bars(8), chicago_build)
        .clip(bars(6)..bars(8), verb_return)
        .apply();

    let drop2 = sequence("synth_drop2").loop_bars(8)
        .clip(0..bars(8), chicago_minimal)
        .clip(0..bars(4), filter_open)
        .clip(bars(4)..bars(6), filter_close)
        .apply();

    let variation = sequence("synth_variation").loop_bars(8)
        .clip(0..bars(8), chicago_high)
        .clip(0..bars(4), phaser_sweep)
        .clip(bars(4)..bars(6), phaser_return)
        .apply();

    let drop3 = sequence("synth_drop3")
        .loop_bars(8)
        .clip(0..bars(8), chicago_busy)
        .apply();

    let groove2 = sequence("synth_groove2").loop_bars(8)
        .clip(0..bars(8), chicago_offbeat)
        .clip(0..bars(4), phaser_sweep)
        .clip(bars(4)..bars(6), phaser_return)
        .apply();

    let breakdown2 = sequence("synth_breakdown2").loop_bars(8)
        .clip(0..bars(6), chicago_held)
        .clip(0..bars(8), filter_big_open)
        .clip(0..bars(6), verb_swell)
        .clip(bars(6)..bars(8), chicago_build)
        .clip(bars(6)..bars(8), verb_return)
        .apply();

    let final_drop = sequence("synth_final").loop_bars(8)
        .clip(0..bars(4), chicago_busy)
        .clip(0..bars(2), filter_big_close)
        .clip(bars(4)..bars(8), chicago_octave)
        .apply();

    let outro = sequence("synth_outro_seq").loop_bars(8)
        .clip(0..bars(8), fade_outro)
        .clip(0..bars(6), chicago)
        .clip(bars(6)..bars(8), chicago_sparse)
        .apply();

    sequence("synth_main")
        .loop_bars(96)
        .clip(bars(24)..bars(32), groove)
        .clip(bars(32)..bars(40), breakdown)
        .clip(bars(40)..bars(48), drop2)
        .clip(bars(48)..bars(56), variation)
        .clip(bars(56)..bars(64), drop3)
        .clip(bars(64)..bars(72), groove2)
        .clip(bars(72)..bars(80), breakdown2)
        .clip(bars(80)..bars(88), final_drop)
        .clip(bars(88)..bars(96), outro)
        .start();

    // Effects
    fx("stab_moog").synth("moog_filter")
        .param("cutoff", 2000.0)
        .param("resonance", 1.5)
        .param("mix", 0.8)
        .apply();
    fx("stab_phaser").synth("phaser")
        .param("rate", 0.3).param("depth", 600.0).param("freq", 1000.0)
        .param("feedback", 0.3).param("mix", 0.3).apply();
    fx("stab_verb")
        .synth("reverb")
        .param("room", 0.7)
        .param("mix", 0.2)
        .apply();
});

// === ATMOSPHERIC PAD ===
let atmosphere = define_group("Atmosphere", || {
    let pad = voice("pad").synth("pad").gain(db(-18)).poly(4);

    let pad_drone = melody("pad_drone").on(pad)
        .notes("E3 - - - - - - - | - - - - - - - - | B2 - - - - - - - | - - - - - - - -");
    let pad_move = melody("pad_move").on(pad)
        .notes("E3 - - - - - - - | - - - - - - - - | G3 - - - - - - - | - - - - - - - -");
    let pad_tension = melody("pad_tension").on(pad)
        .notes("B2 - - - - - - - | - - - - - - - - | E3 - - - - - - - | - - - - - - - -");

    let fade_intro = fade("atmos_intro")
        .on_group("Atmosphere")
        .param("amp")
        .from(db(-25.0))
        .to(db(0.0))
        .over_bars(8);
    let fade_outro = fade("atmos_outro")
        .on_group("Atmosphere")
        .param("amp")
        .from(db(0.0))
        .to(db(-40.0))
        .over_bars(6);
    let verb_open = fade("pad_verb_open")
        .on_effect("pad_verb")
        .param("room")
        .from(0.6)
        .to(0.95)
        .over_bars(4);
    let verb_close = fade("pad_verb_close")
        .on_effect("pad_verb")
        .param("room")
        .from(0.95)
        .to(0.6)
        .over_bars(2);

    let intro = sequence("pad_intro").loop_bars(32)
        .clip(0..bars(8), fade_intro)
        .clip(0..bars(32), pad_drone)
        .apply();

    let breakdown = sequence("pad_breakdown").loop_bars(8)
        .clip(0..bars(8), pad_tension)
        .clip(0..bars(4), verb_open)
        .clip(bars(6)..bars(8), verb_close)
        .apply();

    let outro = sequence("pad_outro").loop_bars(6)
        .clip(0..bars(6), fade_outro)
        .clip(0..bars(6), pad_move)
        .apply();

    sequence("pad_main")
        .loop_bars(96)
        .clip(bars(0)..bars(32), intro)
        .clip(bars(32)..bars(40), breakdown)
        .clip(bars(72)..bars(80), breakdown)
        .clip(bars(90)..bars(96), outro)
        .start();

    fx("pad_verb")
        .synth("reverb")
        .param("room", 0.6)
        .param("damp", 0.3)
        .param("mix", 0.5)
        .apply();
});

// === RISERS ===
let risers = define_group("Risers", || {
    let riser = voice("riser").synth("riser").gain(db(-55)).poly(1);

    // Note durations must match fade durations for the fades to sweep while note is playing
    let rise_tiny = melody("rise_tiny").on(riser).notes("C1 - - - - - - -"); // 1 bar
    let rise_short = melody("rise_short")
        .on(riser)
        .notes("C1 - - - - - - - | - - - - - - - -"); // 2 bars
    let rise_big = melody("rise_big")
        .on(riser)
        .notes("C1 - - - - - - - | - - - - - - - - | - - - - - - - - | - - - - - - - - | - - - - - - - - | - - - - - - - -"); // 6 bars

    let sweep_tiny = fade("sweep_tiny")
        .on_voice("riser")
        .param("cutoff")
        .from(300.0)
        .to(2500.0)
        .over_bars(1);
    let sweep_short = fade("sweep_short")
        .on_voice("riser")
        .param("cutoff")
        .from(200.0)
        .to(3000.0)
        .over_bars(2);
    let sweep_big = fade("sweep_big")
        .on_voice("riser")
        .param("cutoff")
        .from(150.0)
        .to(5000.0)
        .over_bars(6);

    // Amp fades are MULTIPLIERS applied to voice_gain
    // final_amp = event_amp × voice_gain × fade_amp
    let amp_tiny = fade("amp_tiny")
        .on_voice("riser")
        .param("amp")
        .from(0.3)
        .to(1.0)
        .over_bars(1);
    let amp_short = fade("amp_short")
        .on_voice("riser")
        .param("amp")
        .from(0.2)
        .to(1.0)
        .over_bars(2);
    let amp_big = fade("amp_big")
        .on_voice("riser")
        .param("amp")
        .from(0.15)
        .to(1.0)
        .over_bars(6);

    // Riser sequences - must .apply() to register for nesting
    let tiny_riser = sequence("tiny_riser").loop_bars(1)
        .clip(0..bars(1), rise_tiny)
        .clip(0..bars(1), sweep_tiny)
        .clip(0..bars(1), amp_tiny)
        .apply();
    let short_riser = sequence("short_riser").loop_bars(2)
        .clip(0..bars(2), rise_short)
        .clip(0..bars(2), sweep_short)
        .clip(0..bars(2), amp_short)
        .apply();
    let big_riser = sequence("big_riser").loop_bars(6)
        .clip(0..bars(6), rise_big)
        .clip(0..bars(6), sweep_big)
        .clip(0..bars(6), amp_big)
        .apply();

    sequence("riser_main")
        .loop_bars(96)
        .clip(bars(14)..bars(16), short_riser) // Before DROP 1
        .clip(bars(23)..bars(24), tiny_riser) // Before GROOVE
        .clip(bars(38)..bars(40), short_riser) // Before DROP 2
        .clip(bars(47)..bars(48), tiny_riser) // Before VARIATION
        .clip(bars(54)..bars(56), short_riser) // Before DROP 3
        .clip(bars(63)..bars(64), tiny_riser) // Before GROOVE 2
        .clip(bars(74)..bars(80), big_riser) // Before FINAL DROP
        .start();

    fx("riser_verb")
        .synth("reverb")
        .param("room", 0.8)
        .param("damp", 0.3)
        .param("mix", 0.4)
        .apply();
});

// === VOCALS ===
let vocals = define_group("Vocals", || {
    let louder = sample("louder", "./samples/louder.wav");
    let louder_voice = voice("louder").on(louder).gain(db(-20));

    // Pattern variations - different rhythmic feels with just "louder"
    let hit = pattern("louder_hit").on(louder_voice).step("x... .... .... ....");
    let offbeat = pattern("louder_offbeat").on(louder_voice).step(".... x... .... ....");
    let louder_call = pattern("louder_call").on(louder_voice).step("x... .... x... ....");
    let answer = pattern("louder_answer").on(louder_voice).step(".... x... .... x...");
    let build = pattern("louder_build").on(louder_voice).step("x... x... x.x. x.x.");

    // Effect automation for movement
    let verb_swell = fade("vox_verb_swell")
        .on_effect("vocals_verb")
        .param("mix")
        .from(0.2)
        .to(0.7)
        .over_bars(4);
    let verb_return = fade("vox_verb_return")
        .on_effect("vocals_verb")
        .param("mix")
        .from(0.7)
        .to(0.2)
        .over_bars(2);

    // Section sequences

    // Bars 24-32: GROOVE - first appearance, simple hit
    let groove = sequence("vox_groove").loop_bars(8)
        .clip(bars(4)..bars(8), hit)
        .apply();

    // Bars 32-40: BREAKDOWN - build into DROP 2
    let breakdown = sequence("vox_breakdown").loop_bars(8)
        .clip(bars(6)..bars(8), build)
        .apply();

    // Bars 40-48: DROP 2 - offbeat groove
    let drop2 = sequence("vox_drop2").loop_bars(8)
        .clip(0..bars(8), offbeat)
        .apply();

    // Bars 56-64: DROP 3 - call pattern, more energy
    let drop3 = sequence("vox_drop3").loop_bars(8)
        .clip(0..bars(8), louder_call)
        .apply();

    // Bars 72-80: BREAKDOWN 2 - big build with verb wash
    let breakdown2 = sequence("vox_breakdown2").loop_bars(8)
        .clip(0..bars(4), verb_swell)
        .clip(bars(4)..bars(8), build)
        .clip(bars(6)..bars(8), verb_return)
        .apply();

    // Bars 80-88: FINAL DROP - answer pattern, call and response feel
    let final_drop = sequence("vox_final").loop_bars(8)
        .clip(0..bars(8), answer)
        .apply();

    // Main arrangement - louder as rhythmic element at key moments
    sequence("vocals_main")
        .loop_bars(96)
        .clip(bars(24)..bars(32), groove)     // first taste
        .clip(bars(32)..bars(40), breakdown)  // build before DROP 2
        .clip(bars(40)..bars(48), drop2)      // offbeat groove
        .clip(bars(56)..bars(64), drop3)      // call pattern
        .clip(bars(72)..bars(80), breakdown2) // big build before FINAL
        .clip(bars(80)..bars(88), final_drop) // answer to close
        .start();

    fx("vocals_verb")
        .synth("reverb")
        .param("room", 0.6)
        .param("damp", 0.3)
        .param("mix", 0.2)
        .apply();
});