// ============================================================================
// Music Theory Arpeggios Module
// ============================================================================
// Generate arpeggio patterns from chords
// All functions return note arrays compatible with vibelang's .step()

import "stdlib/theory/core.vibe" as core;

// ============================================================================
// Basic Arpeggio Patterns
// ============================================================================

// Ascending arpeggio
fn arpeggio_up(chord) {
    return chord;  // Chords are already in ascending order
}

// Descending arpeggio
fn arpeggio_down(chord) {
    let result = [];
    
    for i in 0..chord.len() {
        result.push(chord[chord.len() - 1 - i]);
    }
    
    return result;
}

// Up then down arpeggio
fn arpeggio_up_down(chord) {
    let result = [];
    
    // Ascending
    for note in chord {
        result.push(note);
    }
    
    // Descending (skip the top note to avoid repetition)
    for i in 1..chord.len() {
        result.push(chord[chord.len() - 1 - i]);
    }
    
    return result;
}

// Down then up arpeggio
fn arpeggio_down_up(chord) {
    let result = [];
    
    // Descending
    for i in 0..chord.len() {
        result.push(chord[chord.len() - 1 - i]);
    }
    
    // Ascending (skip the bottom note)
    for i in 1..chord.len() {
        result.push(chord[i]);
    }
    
    return result;
}

// ============================================================================
// Extended Arpeggios (Multiple Octaves)
// ============================================================================

// Ascending arpeggio with octave extension
fn arpeggio_up_extended(chord) {
    arpeggio_up_extended_ex(chord, 2)
}

fn arpeggio_up_extended_ex(chord, octaves) {
    
    let result = [];
    
    for octave_num in 0..octaves {
        for note in chord {
            result.push(core::shift_octave(note, octave_num));
        }
    }
    
    return result;
}

// Descending arpeggio with octave extension
fn arpeggio_down_extended(chord) {
    arpeggio_down_extended_ex(chord, 2)
}

fn arpeggio_down_extended_ex(chord, octaves) {
    
    let result = [];
    
    for octave_num in 0..octaves {
        let octave_idx = octaves - 1 - octave_num;
        
        for i in 0..chord.len() {
            let note_idx = chord.len() - 1 - i;
            result.push(core::shift_octave(chord[note_idx], octave_idx));
        }
    }
    
    return result;
}

// ============================================================================
// Rhythmic Variations
// ============================================================================

// Arpeggio with rests between notes
fn arpeggio_with_rests(chord) {
    arpeggio_with_rests_ex(chord, "up")
}

fn arpeggio_with_rests_ex(chord, pattern) {
    let base = if pattern == "down" {
        arpeggio_down(chord)
    } else {
        arpeggio_up(chord)
    };
    
    let result = [];
    
    for note in base {
        result.push(note);
        result.push(".");
    }
    
    return result;
}

// Arpeggio with accented first note (repeated)
fn arpeggio_accented(chord) {
    arpeggio_accented_ex(chord, "up")
}

fn arpeggio_accented_ex(chord, pattern) {
    let base = if pattern == "down" {
        arpeggio_down(chord)
    } else {
        arpeggio_up(chord)
    };
    
    let result = [];
    
    if base.len() > 0 {
        result.push(base[0]);  // Accent: repeat first note
        
        for note in base {
            result.push(note);
        }
    }
    
    return result;
}

// ============================================================================
// Broken Chord Patterns
// ============================================================================

// Broken chord pattern: 1-3-2-4 (root, fifth, third, seventh)
fn broken_1_3_2_4(chord) {
    let result = [];
    let len = chord.len();
    
    if len >= 1 { result.push(chord[0]); }  // Root
    if len >= 3 { result.push(chord[2]); }  // Fifth
    if len >= 2 { result.push(chord[1]); }  // Third
    if len >= 4 { result.push(chord[3]); }  // Seventh
    
    return result;
}

// Broken chord pattern: 1-5-3-5 (root, third, root, third)
fn broken_1_5_3_5(chord) {
    
    let result = [];
    let len = chord.len();
    
    if len >= 1 { result.push(chord[0]); }  // Root
    if len >= 2 {
        let third_up = core::shift_octave(chord[1], 1);
        result.push(third_up);  // Third (octave up)
    }
    if len >= 1 {
        let root_up = core::shift_octave(chord[0], 1);
        result.push(root_up);  // Root (octave up)
    }
    if len >= 2 {
        let third_up = core::shift_octave(chord[1], 1);
        result.push(third_up);  // Third (octave up)
    }
    
    return result;
}

// Alberti bass pattern (1-5-3-5, classical accompaniment)
fn alberti_bass(chord) {
    let result = [];
    let len = chord.len();
    
    if len >= 1 { result.push(chord[0]); }  // Root
    if len >= 3 { result.push(chord[2]); }  // Fifth
    if len >= 2 { result.push(chord[1]); }  // Third
    if len >= 3 { result.push(chord[2]); }  // Fifth again
    
    return result;
}

// ============================================================================
// Pattern-Based Arpeggios
// ============================================================================

// Generate arpeggio from custom index pattern
// e.g., [0, 2, 1, 2] = root, fifth, third, fifth
fn arpeggio_pattern(chord, index_pattern) {
    let result = [];
    
    for idx in index_pattern {
        if idx >= 0 && idx < chord.len() {
            result.push(chord[idx]);
        }
    }
    
    return result;
}

// Repeating arpeggio pattern
fn arpeggio_repeat(chord) {
    arpeggio_repeat_ex(chord, "up", 2)
}

fn arpeggio_repeat_ex(chord, pattern, repeats) {
    let base = switch pattern {
        "up" => arpeggio_up(chord),
        "down" => arpeggio_down(chord),
        "up_down" => arpeggio_up_down(chord),
        "down_up" => arpeggio_down_up(chord),
        _ => chord
    };
    
    let result = [];
    
    for i in 0..repeats {
        for note in base {
            result.push(note);
        }
    }
    
    return result;
}

// ============================================================================
// Speed Variations
// ============================================================================

// 8th note arpeggio (normal speed - one note per step)
fn arpeggio_8th(chord) {
    arpeggio_8th_ex(chord, "up")
}

fn arpeggio_8th_ex(chord, pattern) {
    return if pattern == "down" {
        arpeggio_down(chord)
    } else {
        arpeggio_up(chord)
    };
}

// 16th note arpeggio (double speed - would need twice as many steps)
fn arpeggio_16th(chord) {
    arpeggio_16th_ex(chord, "up")
}

fn arpeggio_16th_ex(chord, pattern) {
    let base = if pattern == "down" {
        arpeggio_down(chord)
    } else {
        arpeggio_up(chord)
    };
    
    // Repeat the pattern to fill 16th notes
    let result = [];
    
    for note in base {
        result.push(note);
    }
    for note in base {
        result.push(note);
    }
    
    return result;
}

// Triplet arpeggio (cycle through chord notes in groups of 3)
fn arpeggio_triplet(chord) {
    arpeggio_triplet_ex(chord, 2)
}

fn arpeggio_triplet_ex(chord, cycles) {
    let result = [];
    let len = chord.len();
    
    for cycle in 0..cycles {
        for i in 0..(len * 3) {
            result.push(chord[i % len]);
        }
    }
    
    return result;
}

// ============================================================================
// Style-Specific Arpeggios
// ============================================================================

// Rolling arpeggio (classical/romantic style with slight delay)
// Represented by spreading the chord across multiple steps
fn rolling_arpeggio(chord) {
    let result = [];
    
    // Each note slightly delayed
    for i in 0..chord.len() {
        // Add leading rests for higher notes
        for j in 0..i {
            result.push(".");
        }
        result.push(chord[i]);
    }
    
    return result;
}

// Tremolo arpeggio (rapidly alternating between two notes)
fn tremolo_arpeggio(chord) {
    tremolo_arpeggio_ex(chord, 0, 1, 4)
}

fn tremolo_arpeggio_ex(chord, note1_idx, note2_idx, repeats) {
    let result = [];
    
    if chord.len() > note1_idx && chord.len() > note2_idx {
        for i in 0..repeats {
            result.push(chord[note1_idx]);
            result.push(chord[note2_idx]);
        }
    }
    
    return result;
}

// Cascading arpeggio (waterfall effect)
fn cascading_arpeggio(chord) {
    cascading_arpeggio_ex(chord, 2)
}

fn cascading_arpeggio_ex(chord, cascades) {
    
    let result = [];
    
    for cascade in 0..cascades {
        // Start from top, go down
        for i in 0..chord.len() {
            let note_idx = chord.len() - 1 - i;
            let octave_shift = cascades - 1 - cascade;
            result.push(core::shift_octave(chord[note_idx], octave_shift));
        }
    }
    
    return result;
}

// ============================================================================
// Arpeggio Transformation
// ============================================================================

// Invert arpeggio (flip intervals)
fn invert_arpeggio(arpeggio) {
    
    if arpeggio.len() < 2 {
        return arpeggio;
    }
    
    let result = [arpeggio[0]];  // Keep pivot note
    
    for i in 1..arpeggio.len() {
        if arpeggio[i] != "." && arpeggio[i - 1] != "." {
            let interval = core::interval_semitones(arpeggio[i - 1], arpeggio[i]);
            result.push(core::transpose_note(result[i - 1], 0 - interval));
        } else {
            result.push(arpeggio[i]);
        }
    }
    
    return result;
}

// Transpose entire arpeggio
fn transpose_arpeggio(arpeggio, semitones) {
    
    let result = [];
    
    for note in arpeggio {
        if note == "." {
            result.push(".");
        } else {
            result.push(core::transpose_note(note, semitones));
        }
    }
    
    return result;
}

// ============================================================================
// Utility: Apply Arpeggio to Progression
// ============================================================================

// Apply arpeggio pattern to each chord in progression
fn apply_to_progression(progression) {
    apply_to_progression_ex(progression, "up")
}

fn apply_to_progression_ex(progression, pattern) {
    let result = [];
    
    for chord in progression {
        let arp = switch pattern {
            "up" => arpeggio_up(chord),
            "down" => arpeggio_down(chord),
            "up_down" => arpeggio_up_down(chord),
            "down_up" => arpeggio_down_up(chord),
            "alberti" => alberti_bass(chord),
            _ => chord
        };
        
        for note in arp {
            result.push(note);
        }
    }
    
    return result;
}

