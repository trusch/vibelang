// ============================================================================
// Music Theory Bass Patterns Module
// ============================================================================
// Generate bass lines and patterns from chords and progressions
// All functions return note arrays compatible with vibelang's .step()

import "stdlib/theory/core.vibe" as core;

// ============================================================================
// Root Note Patterns
// ============================================================================

// Simple root note pattern (one root per chord)
fn root_pattern(progression) {
    root_pattern_ex(progression, 4)
}

fn root_pattern_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        if chord.len() > 0 {
            let root = chord[0];
            result.push(root);
            
            // Add rests for remaining beats
            for i in 1..beats_per_chord {
                result.push(".");
            }
        }
    }
    
    return result;
}

// Root on every beat
fn root_on_beats(progression) {
    root_on_beats_ex(progression, 4)
}

fn root_on_beats_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        if chord.len() > 0 {
            let root = chord[0];
            for i in 0..beats_per_chord {
                result.push(root);
            }
        }
    }
    
    return result;
}

// Root with octave jump
fn root_octave_pattern(progression) {
    root_octave_pattern_ex(progression, 4)
}

fn root_octave_pattern_ex(progression, beats_per_chord) {
    
    let result = [];
    
    for chord in progression {
        if chord.len() > 0 {
            let root = chord[0];
            let root_up = core::shift_octave(root, 1);
            
            result.push(root);
            result.push(".");
            result.push(root_up);
            result.push(".");
            
            // Fill remaining beats if needed
            for i in 4..beats_per_chord {
                result.push(".");
            }
        }
    }
    
    return result;
}

// ============================================================================
// Root-Fifth Patterns
// ============================================================================

// Alternating root and fifth
fn root_fifth_pattern(progression) {
    root_fifth_pattern_ex(progression, 4)
}

fn root_fifth_pattern_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        if chord.len() >= 3 {
            let root = chord[0];
            let fifth = chord[2];  // Fifth is third note in triad
            
            for i in 0..beats_per_chord {
                if i % 2 == 0 {
                    result.push(root);
                } else {
                    result.push(fifth);
                }
            }
        }
    }
    
    return result;
}

// Root-fifth-octave pattern
fn root_fifth_octave(progression) {
    root_fifth_octave_ex(progression, 4)
}

fn root_fifth_octave_ex(progression, beats_per_chord) {
    
    let result = [];
    
    for chord in progression {
        if chord.len() >= 3 {
            let root = chord[0];
            let fifth = chord[2];
            let octave = core::shift_octave(root, 1);
            
            result.push(root);
            result.push(fifth);
            result.push(octave);
            result.push(fifth);
            
            // Fill remaining beats
            for i in 4..beats_per_chord {
                result.push(".");
            }
        }
    }
    
    return result;
}

// ============================================================================
// Arpeggio Bass Patterns
// ============================================================================

// Ascending arpeggio
fn arpeggio_ascending(progression) {
    arpeggio_ascending_ex(progression, 4)
}

fn arpeggio_ascending_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        let notes_to_add = if beats_per_chord < chord.len() { beats_per_chord } else { chord.len() };
        
        for i in 0..beats_per_chord {
            if i < notes_to_add {
                result.push(chord[i]);
            } else {
                result.push(".");
            }
        }
    }
    
    return result;
}

// Descending arpeggio
fn arpeggio_descending(progression) {
    arpeggio_descending_ex(progression, 4)
}

fn arpeggio_descending_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        let len = chord.len();
        let notes_to_add = if beats_per_chord < len { beats_per_chord } else { len };
        
        for i in 0..beats_per_chord {
            if i < notes_to_add {
                result.push(chord[len - 1 - i]);
            } else {
                result.push(".");
            }
        }
    }
    
    return result;
}

// Up-down arpeggio pattern
fn arpeggio_up_down(progression) {
    arpeggio_up_down_ex(progression, 4)
}

fn arpeggio_up_down_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        let len = chord.len();
        
        for i in 0..beats_per_chord {
            let idx = if i < len {
                i
            } else if i < (2 * len - 2) {
                (2 * len - 2) - i
            } else {
                0
            };
            
            if idx < len {
                result.push(chord[idx]);
            } else {
                result.push(".");
            }
        }
    }
    
    return result;
}

// ============================================================================
// Walking Bass (Jazz/Swing)
// ============================================================================

// Simple walking bass (root, then approach next root chromatically)
fn walking_bass_simple(progression) {
    walking_bass_simple_ex(progression, 4)
}

fn walking_bass_simple_ex(progression, beats_per_chord) {
    
    let result = [];
    
    for i in 0..progression.len() {
        let chord = progression[i];
        
        if chord.len() == 0 {
            continue;
        }
        
        let root = chord[0];
        result.push(root);
        
        // Fill with chord tones
        for j in 1..(beats_per_chord - 1) {
            if j < chord.len() {
                result.push(chord[j]);
            } else {
                result.push(".");
            }
        }
        
        // Approach tone to next chord
        if i < progression.len() - 1 && progression[i + 1].len() > 0 {
            let next_root = progression[i + 1][0];
            let approach = core::transpose_note(next_root, -1);  // Half step below
            result.push(approach);
        } else {
            result.push(root);
        }
    }
    
    return result;
}

// Bebop walking bass (adds chromatic passing tones)
fn walking_bass_bebop(progression) {
    walking_bass_bebop_ex(progression, 4)
}

fn walking_bass_bebop_ex(progression, beats_per_chord) {
    
    let result = [];
    
    for i in 0..progression.len() {
        let chord = progression[i];
        
        if chord.len() < 3 {
            continue;
        }
        
        // Beat 1: Root
        result.push(chord[0]);
        
        // Beat 2: Third or fifth
        result.push(chord[1]);
        
        // Beat 3: Fifth or seventh
        if chord.len() >= 3 {
            result.push(chord[2]);
        } else {
            result.push(".");
        }
        
        // Beat 4: Chromatic approach to next root
        if i < progression.len() - 1 && progression[i + 1].len() > 0 {
            let next_root = progression[i + 1][0];
            let curr_root = chord[0];
            let interval = core::interval_semitones(curr_root, next_root);
            
            // Choose approach tone
            let approach = if interval > 2 {
                core::transpose_note(next_root, -1)  // Half step below
            } else if interval < -2 {
                core::transpose_note(next_root, 1)   // Half step above
            } else {
                core::transpose_note(curr_root, 2)   // Whole step up
            };
            
            result.push(approach);
        } else {
            result.push(chord[0]);
        }
    }
    
    return result;
}

// ============================================================================
// Rhythmic Bass Patterns
// ============================================================================

// House/EDM four-on-floor (root on every quarter note)
fn house_bass(progression) {
    house_bass_ex(progression, 4)
}

fn house_bass_ex(progression, beats_per_chord) {
    return root_on_beats(progression, beats_per_chord);
}

// Techno syncopated pattern
fn techno_bass(progression) {
    techno_bass_ex(progression, 4)
}

fn techno_bass_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        if chord.len() > 0 {
            let root = chord[0];
            
            // Syncopated: x.x.x..x pattern
            result.push(root);
            result.push(".");
            result.push(root);
            result.push(".");
            
            if beats_per_chord > 4 {
                result.push(root);
                result.push(".");
                result.push(".");
                result.push(root);
            }
        }
    }
    
    return result;
}

// Funk syncopated bass (with anticipated notes)
fn funk_bass(progression) {
    funk_bass_ex(progression, 4)
}

fn funk_bass_ex(progression, beats_per_chord) {
    
    let result = [];
    
    for i in 0..progression.len() {
        let chord = progression[i];
        
        if chord.len() < 2 {
            continue;
        }
        
        let root = chord[0];
        let third = chord[1];
        
        // Funky pattern: root, rest, third, anticipated root
        result.push(root);
        result.push(".");
        result.push(third);
        
        // Anticipate next chord's root on last beat
        if i < progression.len() - 1 && progression[i + 1].len() > 0 {
            result.push(progression[i + 1][0]);
        } else {
            result.push(root);
        }
    }
    
    return result;
}

// Reggae/Ska offbeat bass (emphasizes upbeats)
fn reggae_bass(progression) {
    reggae_bass_ex(progression, 4)
}

fn reggae_bass_ex(progression, beats_per_chord) {
    let result = [];
    
    for chord in progression {
        if chord.len() > 0 {
            let root = chord[0];
            
            for i in 0..beats_per_chord {
                if i % 2 == 1 {  // Upbeats (2 and 4)
                    result.push(root);
                } else {
                    result.push(".");
                }
            }
        }
    }
    
    return result;
}

// Drum and bass pattern (syncopated with octave jumps)
fn dnb_bass(progression) {
    dnb_bass_ex(progression, 4)
}

fn dnb_bass_ex(progression, beats_per_chord) {
    
    let result = [];
    
    for chord in progression {
        if chord.len() >= 3 {
            let root = chord[0];
            let root_low = core::shift_octave(root, -1);
            let fifth = chord[2];
            
            // DnB pattern: LOW root, rest, fifth, rest
            result.push(root_low);
            result.push(".");
            result.push(fifth);
            result.push(".");
            
            for i in 4..beats_per_chord {
                result.push(".");
            }
        }
    }
    
    return result;
}

// Disco octave bass (classic disco pattern)
fn disco_bass(progression) {
    disco_bass_ex(progression, 4)
}

fn disco_bass_ex(progression, beats_per_chord) {
    
    let result = [];
    
    for chord in progression {
        if chord.len() > 0 {
            let root = chord[0];
            let root_up = core::shift_octave(root, 1);
            
            // Disco pattern: Low, high, low, high
            for i in 0..beats_per_chord {
                if i % 2 == 0 {
                    result.push(root);
                } else {
                    result.push(root_up);
                }
            }
        }
    }
    
    return result;
}

// ============================================================================
// Utility: Bass Pattern by Name
// ============================================================================

fn bass_pattern(name, progression) {
    bass_pattern_ex(name, progression, 4)
}

fn bass_pattern_ex(name, progression, beats_per_chord) {
    let n = name.to_lower().replace(" ", "_");
    
    return switch n {
        "root" => root_pattern(progression, beats_per_chord),
        "root_beats" => root_on_beats(progression, beats_per_chord),
        "root_octave" => root_octave_pattern(progression, beats_per_chord),
        "root_fifth" => root_fifth_pattern(progression, beats_per_chord),
        "root_fifth_octave" => root_fifth_octave(progression, beats_per_chord),
        "arpeggio_up" => arpeggio_ascending(progression, beats_per_chord),
        "arpeggio_down" => arpeggio_descending(progression, beats_per_chord),
        "arpeggio_up_down" => arpeggio_up_down(progression, beats_per_chord),
        "walking" => walking_bass_simple(progression, beats_per_chord),
        "walking_bebop" => walking_bass_bebop(progression, beats_per_chord),
        "house" => house_bass(progression, beats_per_chord),
        "techno" => techno_bass(progression, beats_per_chord),
        "funk" => funk_bass(progression, beats_per_chord),
        "reggae" => reggae_bass(progression, beats_per_chord),
        "dnb" => dnb_bass(progression, beats_per_chord),
        "disco" => disco_bass(progression, beats_per_chord),
        _ => throw `Unknown bass pattern: ${name}`
    };
}

// ============================================================================
// Pedal Point Bass
// ============================================================================

// Pedal point (sustain one note throughout)
fn pedal_point(root_note) {
    pedal_point_ex(root_note, 16)
}

fn pedal_point_ex(root_note, duration) {
    let result = [root_note];
    
    for i in 1..duration {
        result.push(".");
    }
    
    return result;
}

// Pedal with rhythmic pattern
fn pedal_rhythmic(root_note, pattern) {
    let result = [];
    
    for step in pattern {
        if step == "x" || step == "X" {
            result.push(root_note);
        } else {
            result.push(".");
        }
    }
    
    return result;
}

// ============================================================================
// Custom Pattern Builder
// ============================================================================

// Build bass line from custom degree pattern
// e.g., [1, 5, 1, 3] plays root, fifth, root, third
fn custom_degree_pattern(chord, degree_pattern) {
    let result = [];
    
    for degree in degree_pattern {
        if degree == 0 {
            result.push(".");
        } else if degree <= chord.len() {
            result.push(chord[degree - 1]);
        } else {
            result.push(".");
        }
    }
    
    return result;
}

// Apply custom degree pattern to entire progression
fn apply_degree_pattern(progression, degree_pattern) {
    let result = [];
    
    for chord in progression {
        let pattern_notes = custom_degree_pattern(chord, degree_pattern);
        for note in pattern_notes {
            result.push(note);
        }
    }
    
    return result;
}

