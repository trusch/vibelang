#!/usr/bin/env node

/**
 * Documentation Generator for VibeLang
 *
 * Generates JSX documentation components from:
 * - UGen manifests (JSON files)
 * - Standard library .vibe files
 *
 * Usage: node scripts/generate-docs.js
 */

const fs = require('fs');
const path = require('path');

const UGEN_MANIFESTS_DIR = path.join(__dirname, '../../crates/vibelang-dsp/ugen_manifests');
const STDLIB_DIR = path.join(__dirname, '../../crates/vibelang-std/stdlib');
const OUTPUT_DIR = path.join(__dirname, '../src/generated');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// ============================================================================
// UGen Documentation Generator
// ============================================================================

function loadUgenManifests() {
  const categories = {};
  const files = fs.readdirSync(UGEN_MANIFESTS_DIR).filter(f => f.endsWith('.json'));

  for (const file of files) {
    const filepath = path.join(UGEN_MANIFESTS_DIR, file);
    const content = fs.readFileSync(filepath, 'utf-8');
    const ugens = JSON.parse(content);
    const categoryName = path.basename(file, '.json');

    // Format category name nicely
    const formattedCategory = categoryName
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    categories[formattedCategory] = ugens;
  }

  return categories;
}

function generateUgenDocsJSX(categories) {
  const categoryNames = Object.keys(categories).sort();

  let jsx = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-docs.js

import React from 'react';

export const ugenCategories = ${JSON.stringify(categoryNames, null, 2)};

export const ugenData = ${JSON.stringify(categories, null, 2)};

export function UGenDocs({ searchTerm = '', selectedCategory = 'all', expandedItem, onCardToggle }) {
  // When searching, always search all categories
  const filteredCategories = (searchTerm || selectedCategory === 'all')
    ? ugenCategories
    : ugenCategories.filter(c => c === selectedCategory);

  return (
    <div className="ugen-docs">
      {filteredCategories.map(category => {
        const ugens = ugenData[category].filter(ugen => {
          if (!searchTerm) return true;
          const term = searchTerm.toLowerCase();
          return ugen.name.toLowerCase().includes(term) ||
                 ugen.description.toLowerCase().includes(term);
        });

        if (ugens.length === 0) return null;

        return (
          <div key={category} className="ugen-category">
            <h3 className="ugen-category__title">{category}</h3>
            <div className="ugen-category__list">
              {ugens.map(ugen => (
                <UGenCard
                  key={ugen.name}
                  ugen={ugen}
                  isExpanded={expandedItem === ugen.name}
                  onToggle={() => onCardToggle(ugen.name)}
                />
              ))}
            </div>
          </div>
        );
      })}
    </div>
  );
}

function UGenCard({ ugen, isExpanded, onToggle }) {
  return (
    <div className={\`ugen-card \${isExpanded ? 'ugen-card--expanded' : ''}\`} data-item-name={ugen.name}>
      <div className="ugen-card__header" onClick={onToggle}>
        <div className="ugen-card__title-row">
          <span className="ugen-card__name">{ugen.name}</span>
          <span className="ugen-card__rates">
            {ugen.rates.map(r => (
              <span key={r} className={\`ugen-card__rate ugen-card__rate--\${r}\`}>{r}</span>
            ))}
          </span>
        </div>
        <p className="ugen-card__description">{ugen.description}</p>
        <span className="ugen-card__expand-icon">{isExpanded ? '−' : '+'}</span>
      </div>

      {isExpanded && (
        <div className="ugen-card__details">
          {ugen.inputs && ugen.inputs.length > 0 ? (
            <table className="ugen-card__params">
              <thead>
                <tr>
                  <th>Parameter</th>
                  <th>Type</th>
                  <th>Default</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                {ugen.inputs.map(input => (
                  <tr key={input.name}>
                    <td className="ugen-card__param-name">{input.name}</td>
                    <td className="ugen-card__param-type">{input.type}</td>
                    <td className="ugen-card__param-default">{input.default}</td>
                    <td className="ugen-card__param-desc">{input.description}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : (
            <p className="ugen-card__no-params">No parameters - this UGen has no configurable inputs.</p>
          )}
        </div>
      )}
    </div>
  );
}

export default UGenDocs;
`;

  return jsx;
}

// ============================================================================
// Standard Library Documentation Generator
// ============================================================================

function parseVibeFile(filepath) {
  const content = fs.readFileSync(filepath, 'utf-8');
  const lines = content.split('\n');
  const results = [];

  // Parse file-level metadata from first line comment
  let fileDescription = '';
  let fileGenre = '';
  let fileCharacter = '';

  if (lines[0] && lines[0].startsWith('//')) {
    const comment = lines[0].substring(2).trim();
    const genreMatch = comment.match(/Genre:\s*([^|]+)/i);
    const charMatch = comment.match(/Character:\s*(.+)/i);

    if (genreMatch) fileGenre = genreMatch[1].trim();
    if (charMatch) fileCharacter = charMatch[1].trim();
    fileDescription = fileCharacter || comment;
  }

  // Find all synthdef and fx definitions in the file
  // Match the entire definition block from define_synthdef/define_fx to the closing });
  const definitionRegex = /(define_synthdef|define_fx)\s*\(\s*"([^"]+)"\s*,\s*\|builder\|\s*\{([\s\S]*?)\}\s*\)\s*;/g;

  let match;
  while ((match = definitionRegex.exec(content)) !== null) {
    const type = match[1] === 'define_synthdef' ? 'synthdef' : 'fx';
    const name = match[2];
    const body = match[3];

    // Extract parameters only from this definition's body
    const params = [];
    const paramMatches = body.matchAll(/\.param\s*\(\s*"([^"]+)"\s*,\s*([^)]+)\)/g);
    for (const paramMatch of paramMatches) {
      params.push({
        name: paramMatch[1],
        default: parseFloat(paramMatch[2]) || paramMatch[2].trim()
      });
    }

    // Look for inline comment above this definition for description
    const defStart = match.index;
    const beforeDef = content.substring(0, defStart);
    const lastLines = beforeDef.split('\n').slice(-3);
    let description = fileDescription;

    for (const line of lastLines.reverse()) {
      if (line.trim().startsWith('//')) {
        const comment = line.trim().substring(2).trim();
        // Skip empty comments or comments that are just dashes
        if (comment && !comment.match(/^-+$/)) {
          description = comment.split(' - ')[1] || comment; // Get description after dash if present
          break;
        }
      }
    }

    results.push({
      name,
      description,
      genre: fileGenre,
      character: fileCharacter,
      params,
      type,
      source: match[0] // Just the definition, not the whole file
    });
  }

  // If no definitions found, return empty array
  if (results.length === 0) {
    // Fallback: try to at least get something from the file
    const synthdefMatch = content.match(/define_synthdef\s*\(\s*"([^"]+)"/);
    const fxMatch = content.match(/define_fx\s*\(\s*"([^"]+)"/);

    if (synthdefMatch || fxMatch) {
      results.push({
        name: synthdefMatch ? synthdefMatch[1] : fxMatch[1],
        description: fileDescription,
        genre: fileGenre,
        character: fileCharacter,
        params: [],
        type: synthdefMatch ? 'synthdef' : 'fx',
        source: content
      });
    }
  }

  return results;
}

function scanStdlibDirectory(dir, category = '', subcategory = '') {
  const items = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      // Recurse into subdirectory
      const newCategory = category || entry.name;
      const newSubcategory = category ? entry.name : '';
      items.push(...scanStdlibDirectory(fullPath, newCategory, newSubcategory));
    } else if (entry.name.endsWith('.vibe') && entry.name !== 'index.vibe') {
      const parsedItems = parseVibeFile(fullPath);
      const relativePath = path.relative(STDLIB_DIR, fullPath);
      for (const parsed of parsedItems) {
        parsed.category = category;
        parsed.subcategory = subcategory;
        parsed.path = relativePath;
        items.push(parsed);
      }
    }
  }

  return items;
}

function organizeStdlib(items) {
  const organized = {};

  for (const item of items) {
    const category = item.category.charAt(0).toUpperCase() + item.category.slice(1);

    if (!organized[category]) {
      organized[category] = {
        subcategories: {},
        items: []
      };
    }

    if (item.subcategory) {
      const sub = item.subcategory.charAt(0).toUpperCase() + item.subcategory.slice(1);
      if (!organized[category].subcategories[sub]) {
        organized[category].subcategories[sub] = [];
      }
      organized[category].subcategories[sub].push(item);
    } else {
      organized[category].items.push(item);
    }
  }

  return organized;
}

function generateStdlibDocsJSX(organized) {
  const categories = Object.keys(organized).sort();

  // Create a flat list for search
  const allItems = [];
  for (const category of categories) {
    const cat = organized[category];
    allItems.push(...cat.items.map(i => ({ ...i, categoryName: category })));
    for (const [subName, subItems] of Object.entries(cat.subcategories)) {
      allItems.push(...subItems.map(i => ({ ...i, categoryName: category, subcategoryName: subName })));
    }
  }

  let jsx = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-docs.js

import React from 'react';
import { highlightCode } from '../utils/syntaxHighlight';

export const stdlibCategories = ${JSON.stringify(categories, null, 2)};

export const stdlibData = ${JSON.stringify(organized, null, 2)};

export const stdlibAllItems = ${JSON.stringify(allItems, null, 2)};

// Get subcategories for a category
export function getSubcategories(category) {
  const catData = stdlibData[category];
  if (!catData) return [];
  return Object.keys(catData.subcategories).sort();
}

export function StdlibDocs({ searchTerm = '', selectedCategory = 'all', expandedItem, onCardToggle }) {
  // Parse category/subcategory from selectedCategory (e.g., "Bass/Acid")
  const [mainCategory, selectedSubcategory] = selectedCategory.includes('/')
    ? selectedCategory.split('/')
    : [selectedCategory, null];

  // When searching, always search all categories
  const filteredCategories = (searchTerm || selectedCategory === 'all')
    ? stdlibCategories
    : stdlibCategories.filter(c => c === mainCategory);

  return (
    <div className="stdlib-docs">
      {filteredCategories.map(category => {
        const catData = stdlibData[category];

        // Filter items based on search
        const filterItems = (items) => {
          if (!searchTerm) return items;
          const term = searchTerm.toLowerCase();
          return items.filter(item =>
            item.name.toLowerCase().includes(term) ||
            (item.description && item.description.toLowerCase().includes(term)) ||
            (item.genre && item.genre.toLowerCase().includes(term))
          );
        };

        // If a subcategory is selected, only show items from that subcategory
        let filteredItems = [];
        let filteredSubs = {};
        let hasAnyResults = false;

        if (selectedSubcategory) {
          // Only show the selected subcategory
          const subItems = catData.subcategories[selectedSubcategory];
          if (subItems) {
            const filtered = filterItems(subItems);
            if (filtered.length > 0) {
              filteredSubs[selectedSubcategory] = filtered;
              hasAnyResults = true;
            }
          }
        } else {
          // Show all items in category
          filteredItems = filterItems(catData.items);
          hasAnyResults = filteredItems.length > 0;

          for (const [subName, subItems] of Object.entries(catData.subcategories)) {
            const filtered = filterItems(subItems);
            if (filtered.length > 0) {
              filteredSubs[subName] = filtered;
              hasAnyResults = true;
            }
          }
        }

        if (!hasAnyResults) return null;

        return (
          <div key={category} className="stdlib-category">
            <h3 className="stdlib-category__title">
              {selectedSubcategory ? category + ' / ' + selectedSubcategory : category}
            </h3>

            {/* Top-level items (no subcategory) */}
            {filteredItems.length > 0 && (
              <div className="stdlib-category__list">
                {filteredItems.map(item => (
                  <StdlibCard
                    key={item.name}
                    item={item}
                    isExpanded={expandedItem === item.name}
                    onToggle={() => onCardToggle(item.name)}
                  />
                ))}
              </div>
            )}

            {/* Subcategories */}
            {Object.entries(filteredSubs).map(([subName, items]) => (
              <div key={subName} className="stdlib-subcategory">
                {!selectedSubcategory && <h4 className="stdlib-subcategory__title">{subName}</h4>}
                <div className="stdlib-subcategory__list">
                  {items.map(item => (
                    <StdlibCard
                      key={item.name}
                      item={item}
                      isExpanded={expandedItem === item.name}
                      onToggle={() => onCardToggle(item.name)}
                    />
                  ))}
                </div>
              </div>
            ))}
          </div>
        );
      })}
    </div>
  );
}

function StdlibCard({ item, isExpanded, onToggle }) {
  const [showUsage, setShowUsage] = React.useState(false);
  const [showSource, setShowSource] = React.useState(false);

  // Reset collapsible sections when card is collapsed
  React.useEffect(() => {
    if (!isExpanded) {
      setShowUsage(false);
      setShowSource(false);
    }
  }, [isExpanded]);

  // Generate usage example based on type
  const getUsageExample = () => {
    const importLine = 'import "stdlib/' + item.path + '";';

    if (item.type === 'fx') {
      // Effect usage example - use fx().synth().param().apply() syntax
      const paramCalls = item.params && item.params.length > 0
        ? item.params.map(p => '    .param("' + p.name + '", ' + p.default + ')').join('\\n')
        : '    .param("mix", 0.3)';

      return importLine + '\\n\\n' +
        '// Add effect to group\\n' +
        'fx("my_' + item.name.split('_')[0] + '")\\n' +
        '    .synth("' + item.name + '")\\n' +
        paramCalls + '\\n' +
        '    .apply();';
    } else {
      // Synthdef usage example - include set_param for each parameter (except gate)
      const paramCalls = item.params && item.params.length > 0
        ? item.params
            .filter(p => p.name !== 'gate')
            .map(p => '    .set_param("' + p.name + '", ' + p.default + ')')
            .join('\\n')
        : '';

      return importLine + '\\n\\n' +
        '// Create a voice\\n' +
        'let v = voice("my_' + item.category + '")\\n' +
        '    .synth("' + item.name + '")' + (paramCalls ? '\\n' + paramCalls : '') + ';\\n\\n' +
        '// Trigger it\\n' +
        'v.trigger();';
    }
  };

  return (
    <div className={\`stdlib-card \${isExpanded ? 'stdlib-card--expanded' : ''}\`} data-item-name={item.name}>
      <div className="stdlib-card__header" onClick={onToggle}>
        <div className="stdlib-card__title-row">
          <span className="stdlib-card__name">{item.name}</span>
          <span className={\`stdlib-card__type stdlib-card__type--\${item.type}\`}>
            {item.type}
          </span>
        </div>
        {item.genre && <span className="stdlib-card__genre">{item.genre}</span>}
        <p className="stdlib-card__description">{item.description}</p>
        <span className="stdlib-card__expand-icon">{isExpanded ? '−' : '+'}</span>
      </div>

      {isExpanded && (
        <div className="stdlib-card__details">
          {/* Parameters - shown by default (gate parameter is filtered out) */}
          {item.params && item.params.filter(p => p.name !== 'gate').length > 0 && (
            <div className="stdlib-card__params-section">
              <h5>Parameters</h5>
              <table className="stdlib-card__params">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Default</th>
                  </tr>
                </thead>
                <tbody>
                  {item.params.filter(p => p.name !== 'gate').map(param => (
                    <tr key={param.name}>
                      <td className="stdlib-card__param-name">{param.name}</td>
                      <td className="stdlib-card__param-default">{param.default}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {/* Usage - collapsed by default */}
          <div className="stdlib-card__collapsible-section">
            <button
              className="stdlib-card__section-toggle"
              onClick={(e) => { e.stopPropagation(); setShowUsage(!showUsage); }}
            >
              {showUsage ? '▾ Hide Usage' : '▸ View Usage'}
            </button>
            {showUsage && (
              <pre className="stdlib-card__code"><code>{highlightCode(getUsageExample())}</code></pre>
            )}
          </div>

          {/* Source - collapsed by default */}
          {item.source && (
            <div className="stdlib-card__collapsible-section">
              <button
                className="stdlib-card__section-toggle"
                onClick={(e) => { e.stopPropagation(); setShowSource(!showSource); }}
              >
                {showSource ? '▾ Hide Source' : '▸ View Source'}
              </button>
              {showSource && (
                <pre className="stdlib-card__code stdlib-card__code--source"><code>{highlightCode(item.source)}</code></pre>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default StdlibDocs;
`;

  return jsx;
}

// ============================================================================
// Main
// ============================================================================

function main() {
  console.log('Generating VibeLang documentation...\n');

  // Generate UGen docs
  console.log('Loading UGen manifests...');
  const ugenCategories = loadUgenManifests();
  const ugenCount = Object.values(ugenCategories).reduce((acc, arr) => acc + arr.length, 0);
  console.log('  Found ' + ugenCount + ' UGens in ' + Object.keys(ugenCategories).length + ' categories');

  const ugenJsx = generateUgenDocsJSX(ugenCategories);
  const ugenOutputPath = path.join(OUTPUT_DIR, 'UGenDocs.jsx');
  fs.writeFileSync(ugenOutputPath, ugenJsx);
  console.log('  Written to ' + ugenOutputPath);

  // Generate stdlib docs
  console.log('\nScanning standard library...');
  const stdlibItems = scanStdlibDirectory(STDLIB_DIR);
  console.log('  Found ' + stdlibItems.length + ' items');

  const organizedStdlib = organizeStdlib(stdlibItems);
  console.log('  Organized into ' + Object.keys(organizedStdlib).length + ' categories');

  const stdlibJsx = generateStdlibDocsJSX(organizedStdlib);
  const stdlibOutputPath = path.join(OUTPUT_DIR, 'StdlibDocs.jsx');
  fs.writeFileSync(stdlibOutputPath, stdlibJsx);
  console.log('  Written to ' + stdlibOutputPath);

  console.log('\nDone!');
}

main();
